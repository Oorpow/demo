Basic
=====
JS的组成
-----
* ECMAScript
* DOM(文档对象模型)
* BOM(浏览器对象模型)

Js特点
---
* 解释型语言
* 类似C、Java的语法结构
* 动态语言
* 基于原型的面向对象

基础认知
---
* 字面量
  * 一些不可改变的值，如1，2，3
  * 字面量可直接使用，但一般不用

* 变量
  * 可以用于保存字面量，且变量的值可以任意改变

* 标识符
  * 可以包含：字母，数字，下划线，$
  * 不能以数字开头
  * 不能是ES标准中的关键字或保留字
  * 一般采用驼峰命名

* 注意事项
  * js底层标识符保存时，采用unicode编码，即utf-8含有的内容，均可作为标识符

数据类型 == 字面量的类型
---
* 基本数据类型
  * String
  * Number
    * 所有数值均为NumberLeixing ,包括浮点
    * js中，整数运算基本可以保证精确，但若进行浮点运算，会得到一个不精确的数字  
  * Boolean
  * NULL
    * NULL类型只有一个值，Null
    * Null表示一个空对象 
  * Undefined
    * Undefined类型只有一个值，Undefined
    * 当声明一个变量，但不进行赋值，此时该变量为Undefined 

  * typeof
    * 用于检查一个变量的类型
    * 用法：typeof 变量名 
    * special：typeof null -> object，typeof undefined -> undefined，typeof NaN -> Number

  * NaN
    * 非数，not a number 

* 引用数据类型
  * Object

强制类型转换
---
* 其他类型转String
  * Plan A：调用被转换数据类型的toString()方法，如，var a = 1; a = a.toString();   // a = "1";
    * 该方法不会影响原变量，但会将转换后的结果返回
    * Null,Undefined无toString()方法
  * Plan B：调用String()方法，如,String(a);
    * 对于Number，Boolean来说，调用String()，实际相当于调用toString()
    * 对于Null,Undefined，则会转为"Null"，"Undefined"

* 其它转Number
  * Plan A：调用Number()，即 a = Number(a);
    * 若字符串是纯数字，则会转为数字
    * 若有非数，则为NaN
    * 若是空串，或为空格，则为0
    * true -> 1，false -> 0，null -> 0，undefined -> NaN  
  * Plan B：parseInt()
    * 将串中有效的整数取出，转为Number，如 a = parseInt(a);
  * Plan C：parseFloat()
    * 操作与parseInt相同，不仅能获取整数，还能获取小数
  * 若对非String使用parseInt，parseFloat，会将其先转为String，后再进行判断，如
    * a = true; a = parseInt(a); console.log(typeof a); // Number console.log(a); // NaN

* 其它转Boolean
  * 数字 -> Bool，除0，NaN外，均为true
  * 字符串 -> Bool，除空串外，均为true
  * Null,Undefined -> Bool，为false
  * Object -> Bool,true 

对象
---
* 基本数据类型都是单一的值，值与值之间没有联系
* 对象作为复合的数据类型，对象可保存多个不同数据类型的属性
  * 内建对象
    * 由ES标准中定义的对象，在任何ES中均可使用，如Math，String...
  * 宿主对象
    * 由js的运行环境提供的对象，主要是浏览器提供，如DOM,BOM
  * 自定义对象
    * 由开发人员自行创建

* 对象的创建
  * 用new调用的函数，是构造函数constructor
  * 构造函数，专门用于创建对象

* 属性
  * 对象中保存的值，即属性
  * 属性的添加/修改：对象.属性名 = 属性值
  * 属性的读取：对象.属性名
    * 若读取的属性不存在，不会报错，而会返回undefined
  * 属性的删除：delete 对象.属性名


* 特殊属性名
  * 对象["属性名"] = 属性值，读取也使用该法
  * []中可直接传递一个变量，如，obj["123"] = 789; var n = "123"; console.log(obj[n]); // 789

* 属性值
  * js对象的属性值，可以是任意数据类型，也可以是一个对象 
  * 检查一个对象是否有指定属性： "属性名" in 对象

基本数据类型，引用数据类型的存储方式
---
* js中的变量保存在栈内存中
* 基本数据类型的值存在栈内存中
  * 值之间独立存在，修改一个变量不影响其他变量
* 对象保存在堆内存中
  * 每创建一个新对象，就开辟出一个新的内存空间，而变量保存的是对象的内存地址（引用地址）
  * 若两个变量保存的是同一个对象的地址，则修改时会互相影响
* 当比较两个基本数据类型的值时，直接比较值，若比较引用数据类型的值时，则比较对象的内存地址

对象字面量创建对象
* var obj = {属性名:属性值}; //键值对

函数
---
* 函数属于对象
  * 可用于封装一些功能，需要时执行
* 函数声明创建函数
  * function 函数名(形参){}
* 函数表达式创建函数
  * var 函数名 = function(形参){}
* 形参
  * 多个形参之间，逗号隔开
  * 声明形参，相当于在函数内部声明对应的变量，但不赋值！！
* 实参
  * 调用函数时，在()中指定实参
  * 实参会赋值给函数中对应的形参
  * 调用函数时，解析器不会检查实参数量！多余实参不会被赋值！
  * 若实参的数量少于形参，则无对应实参的形参的值为undefined

返回值
---
* return后的值会作为函数的执行结果返回
* 函数中，在return语句执行后的语句都不会执行
* 若return后面不跟任何值，则相当于返回一个undefined，即 return; 若函数中不写return，则也会返回undefined

枚举对象中的属性
---
* for(var 变量 in 对象){}
* for in，对象有几个属性，循环体就执行对应的次数，且每次执行时，会将对象中的一个属性的名字赋值给变量
* 语法：var obj = {name:"z",gender:"male"}; for(var i in obj){ console.log(i); //name gender console.log(obj[i]);//"z" "male" } 

作用域
---
* 作用域，指一个变量的作用范围
* 分为全局作用域，函数作用域
* 全局作用域
  * 直接写在script标签中的js代码，处于全局作用域
  * 全局作用域，在页面打开时创建，关闭时销毁
  * 含有一个全局对象window，由浏览器创建，代表浏览器的窗口
  * 全局作用域中，创建的变量会作为window对象的属性保存！创建的函数会作为window的方法保存！
* 函数作用域
  * 调用函数时创建，函数执行完毕销毁
  * 每次调用函数，都会创建一个新的作用域，且它们之间独立存在
  * 函数作用域中，可访问到全局的变量，而全局则无法访问到函数作用域内部的变量
  * 在函数作用域中操作变量时，会先在自身作用域寻找，若没有，则向上查找，直到全局，若全局也找不到，则报错ReferenceError

this的指向
---
* 浏览器在调用函数时，每次都会向函数内部传一个隐含参数：this
* this指向一个对象，即函数执行的上下文对象
* 根据函数的调用方式的不同，this也会指向不同的对象
  * 以函数形式调用时，this指向window，如：func(); // this -> window
  * 以方法形式调用时，this指向调用方法的那个对象，如 var per = func(); // this -> per 

变量和函数的声明提前
---
* 变量声明提前
  * 使用var声明的变量，会在所有代码执行前被声明，但不赋值！ 
* 函数声明提前
  * 使用function 函数名(){}，即函数声明形式创建的函数，会在所有代码执行前被创建

构造函数
---
* 其创建方式与普通函数没有区别，唯一特别，采用大驼峰命名
* 调用方法与普通函数不同，使用new调用
* 执行流程：
  * 创建一个新对象 
  * 将新建的对象，设置为函数中的this
  * 逐步执行函数中的代码
  * 将新建的对象作为返回值返回
  * function Person(name,age){this.name = name, this.age = age}   var man = new Person("Wow",16);
* 使用同一构造函数创建的对象，称为一类对象，也将一个构造函数成为一个类
* 通过一个构造函数创建的对象，成为该类的实例，如201行的man，称man是Person类的一个实例
* 检查一个对象是否是一个类的实例的方法：
  * 对象 instanceof 类，man instanceof Person;

原型
---
* 我们所创建的每一个函数，解析器都会向函数中添加属性prototype，该属性对应着一个对象，即原型对象
* 若函数作为普通函数调用prototype时，没有任何作用
* 以构造函数调用时，它所创建的对象都有一个隐含属性指向该构造函数的原型对象，即 _ _proto_ _
* 原型对象，相当于一个公共区域，所有同一个类的实例都能访问
  * 因此可将对象中共有的内容，统一设置到原型对象中
  * 优点：不污染全局，不用给每个对象添加，就能具有属性，方法
* 向原型添加属性：
  * 类名.prototype.属性名 = 值;
  * 当访问对象的一个属性或方法时，会在自身对象中寻找，找不到会去原型找
* 检查对象中是否含有某个属性：
  * "属性名" in 对象;
  * 该方法若对象中没有，而原型有，也会返回true
  * 对象.hasOwnProperty("属性名"); 
  * 该方法只有对象自身含有属性时，才返回true
* 注意：
  * 原型对象也有原型
  * 属性的查找，会一直到Object的原型，若在Object中没有找到，则返回undefined
* 附加
  * 若直接在页面打印一个对象，实际上是在输出该对象的toString()方法的返回值
  * 若想在输出对象时，不输出[object Object]，则可为对象添加toString()方法，如下：
  * var per = new Person("z",16);
  * Person.prototype.toString = function(){
  *   return "Person[name = +'this.name'+, age = +'this.age'+]";
  * }
  * var result = per.toString();
  * console.log(result);

垃圾回收(GC)
---
* 当一个对象没有任何变量或属性引用它时，此时就为垃圾
* 垃圾过多时，会占用大量内存空间，导致程序运行变慢
* js中有自动的垃圾回收机制

数组
---
* 数组也是对象，用于存储值，存储性能优于普通对象
* 数组的创建：
  * var arr = new Array();
  * var arr = [1,23,3];
* 向数组中添加元素
  * 数组[索引] = 值;
* 向数组最后一位添加元素
  * 数组[数组.length] = 值; 
* 读取数组中的元素
  * 数组[索引]，若索引不存在，则返回undefined
* 获取数组的长度
  * 数组.length
  * 对于内部数据连续的数组，length可以获取到元素的个数
  * 对于不连续的数组，length获取到的则是最大索引值+1
  * 修改length时，若length大于原长度，则多出的部分会空着，若小于，则多出的元素会被删除

数组字面量
---
* 创建数组：
  * var arr = [];
* 使用字面量创建数组时，可以在创建时就指定数组元素
* 使用构造函数创建数组，也可同时添加元素，将元素作为构造函数的参数传递，元素之间逗号隔开
  * var arr = new Array(10,20);
  * arr = new Array(10); //长度为10的数组
  * 数组中的元素可以是任何类型的数据

数组的操作方法
---
* push()
  * 向数组末尾添加元素，并将数组新的长度作为返回值返回
  * var arr = [1,2,3];
  * var result = arr.push(3,3,3);
  * console.log(result); // 6
* pop()
  * 删除最后一个元素，并将被删除的元素作为返回值返回
  * arr.pop();
* unshift()
  * 向开头添加元素，并返回新的数组长度
* shift()
  * 删除第一个元素，并将被删除的元素作为返回值返回

数组的遍历及特殊方法
---

* forEach()
* 支持IE8及以上
* 需要一个函数作为参数
  * 此类函数，由开发人员创建，但不由开发人员调用，即回调函数
  * 执行的次数根据数组中元素的个数决定，每次执行时，浏览器会将遍历的元素以实参的形式传递
  * 浏览器在回调函数中传递3个参数
    * 遍历的元素
    * 遍历元素的索引
    * 遍历的数组
  * arr.forEach(function(val,index,arred)){}

* slice(startIndex,endIndex)
* 用于从数组中提取指定的元素
  * startIndex：开始位置的索引，包括开始
  * endIndex：结束位置的索引，不包括结束，值可以为负，若为负，即从后向前提取
* 该方法不会改变数组元素，而会将截取下来的元素封装到一个新的数组返回

* splice(startIndex,quantity,newElement,newElement)
* 删除数组中的指定元素
* 会改变原数组，会将指定的元素从原数组中删除，并将被删除的元素作为返回值返回
  * startIndex：开始位置的索引
  * quantity：被删除的元素的数量
  * newElement：新的元素
  * arr = [1,2];
  * var result = arr.splice(0,1,"z");

数组去重
---
* var arr = [1,2,2,33,33,4];
* for(var i = 0;i < arr.length; i ++){
* //遍历第i位后的数据
*  for(var j = i + 1; j < arr.length; j ++){
*   if(arr[i] == arr[j]){
*     arr.splice(j,1);
*     j--;
*   }
*  }
* }

连接多个数组
---
* concat()
* 链接多个数组，并将新的数组返回，不影响原数组
* var result = arr.concat(数组1，数组2);

将数组转为一个字符串
---
* join()
* 将数组转为一个字符串，并将转换后的字符串作为结果返回，不影响原数组
* 数组.join("连接符"); // 连接符默认为逗号

反转数组
---
* reverse()
* 反转数组，且会修改原数组

排序
---
* sort()
* 排序，会影响原数组，默认按unicode编码排序，因此，数字也会按照unicode排序，所以可能出错
* 也可自定排序规则，通过添加一个回调函数，如：
* arr.sort(function(a,b)){
*  return 0;  // 不变
*  return 1;  // 交换
*  return -1; // 不变
* }
* 或者return a - b;  // 升序
* return b - a;      // 降序

call(),apply()
---
* 均为函数对象的方法，通过函数对象调用
* call(),apply()调用时，都会执行一次函数
* 调用时，可将一个对象指定为第一个参数，此时该对象会成为函数执行时的this
  * function fun(){
  *   alert(this.name);
  * }
  * var obj = {name: "s"};
  * var obj2 = {name: "z"};
  * fun.call(obj2);  // z
* call()可将实参放在对象后传递，如：call(obj,2);
* apply()，将实参封装到一个数组中统一传递

Arguments
---
* 即参数列表(实参)
* 函数调用时，browser每次都会传两个隐含参数
  * 函数上下文对象 this
  * 封装实参的对象 arguments
    * arguments是类数组对象，也有索引，长度
    * arguments.length; //获取实参长度
    * arguments callee，该属性对应一个函数对象，即当前指向的函数对象  

Date
---
* 创建Date对象
  * var time = new Date();
  * 上述使用构造函数创建的Date对象，会封装为当前代码执行的时间
* getDate()
  * 获取当前日期对象是几号
* getDay()
  * 获取当前日期是周几
  * 值范围为0-6，0 = 周日
* getMonth()
  * 获取月份
  * 值为0-11，0 = 1月
* getFullYear()
  * 获取年份
* getTime()
  * 获取时间戳
  * 即格林威治时间，1970.1.1，0:0:0到当前日期所花费的毫秒数
  * 计算机底层保存时间使用的就是时间戳

Math
---
* 非构造函数，属于工具类，封装了数学运算相关属性方法
* abs()
  * 计算绝对值
* ceil()
  * 向上取整
* floor()
  * 向下取整
* round()
  * 四舍五入取整
* random()
  * 生成0-1的随机数，random()X10，即0-10
* Math.round(Math.random() X (y-x) + x)
  * 生成x-y之间的随机数，xy自取值
* max(),min()
  * 取最大/最小值 

))包装类
---
* js中有3个包装类，通过这3个，可将基本数据类型的数据转为对象，String(),Boolean(),Number()
  * 实际应用中，不使用基本数据类型的对象，因为在做比较时可能会出错
* 方法与属性只能添加给对象，不能给基本数据类型
* 若使用基本数据类型的值去调用属性、方法时：
  * browser会临时用包装类将其转为对象
  * 在调用属性/方法完毕后，再转为原本的类型

String的方法
---
* 在底层，string是以字符数组的形式保存的
* charAt(索引)
  * 返回指定位置的字符，根据索引
  * 不会改变原数组，采用返回值的形式
* charCodeAt(索引)
  * 获取指定位置字符的unicode编码
* String.fromCharCode(字符编码)
  * 根据字符编码获取字符  
* concat()
  * 链接多个字符串
* indexof("查找的值",开始查找的索引位置)
  * 检查字符串中是否含有指定内容，若有，则返回第一次的索引值，若无，返回-1
* lastIndexOf()
  * 用法一致与indexof，lastIndexOf是从后往前查找 
* slice(开始位置的索引，结束索引)
  * 从字符串中截取指定内容，不影响原字符串 

正则表达式
---
* 用于定义一些字符串的规则
  * 计算机可以根据正则，检查一个string是否符合规则，并将其中符合规则的内容提取出来
* 创建正则表达式对象
  * var 变量 = new RegExp("正则表达式","匹配模式");
  * typeof 正则对象，会返回Object
  * 匹配模式：
    * i：忽略大小写
    * g：全局匹配
* 检查一个字符串是否符合正则表达式规则
  * test()
* 字面量创建正则表达式
* var 变量 = /正则/匹配模式
  * |：或者
  * []：或，[ab]，即是否有a或b
  * [^]：除...之外
* 以...开头或结尾
  * ^：/^a/，以a开头
  * $：/a$/，以a结尾
  * \w：任意数字/字母
  * \W：除任意数字/字母以外
  * \d：[0-9]
  * \D：除了[0-9]以外
  * \s：空格
  * \S，除空格之外
  * \b，单词边界
  * \B，除单词边界以外 

DOM
---
* Document Object Model
  * js中，通过DOM对HTML文档进行操作
  * Document：HTML网页文档
  * Object：将网页中每一个部分转为一个对象
  * Model：表示对象之间的关系，方便获取对象
* Node
  * 构成网页的最基本的组成部分，网页中的每个部分都能成为一个节点
    * 标签：元素节点
    * 属性：属性节点
    * 文本：文本节点
    * 文档：文档节点

事件))
---
* 指文档或browser窗口中发生的一些特定的交互瞬间
* js与html的交互是通过事件实现的
* 浏览器在加载一个页面时，按照自上向下的顺序加载
  * 因此，js代码写在页面下方，是为了在页面加载完后才执行
  * 若想写在页面上方，可用window.onload = function() {}
  * 若不采取上述方法，在执行时页面未加载，DOM对象也未加载，会导致无法获取到DOM对象
* this指向：
  * 事件的响应函数中，响应函数绑定的是谁，this指向谁
  * var checkBox = document.getElementById("btn");
  * checkBox.onclick = function(){
  *   this === checkBox;  // true
  * }
* 事件对象))
  * 当事件的响应函数被触发时，browser会将一个事件对象作为实参传入响应函数，在事件对象中封装了当前事件相关的一切信息 
* 事件冒泡))
  * 指事件的向上传导，当后代元素的事件被触发时，祖先元素的相同事件也被触发
  * 取消冒泡：
    * event.cancelBubble = true;
* 事件委托))
  * 将事件统一绑定给元素的共同的父元素，当子元素上的事件触发时，会冒泡到父元素，再通过父元素的响应函数处理
  * 事件委托利用了冒泡，减少了事件绑定次数，提高程序性能
  * <ul> <li><a href="#"></a></li>  <li><a href="#"></a></li>  </ul>
  * ul.onclick = function(){
  *   alert("z");
  * }
  * 此时点击a会直接输出z，且新添加的a也拥有相同的功能
* 事件传播))
  * 捕获阶段
    * 从外向内进行捕获，默认此时不触发事件
    * 若想在捕获时触发，则可将addEventListener()中的false改为true
    * w3c认为最外层应是document，其余则认为是window 
  * 目标阶段
    * 事件捕获到目标元素，捕获结束后，开始在目标上触发事件 
  * 冒泡阶段 
    * 事件从目标元素传到父元素，依次触发 
  * IE8及及以下，没有捕获阶段
* addEventListener("事件字符串",function(){},bool)
  * 可以绑定多个响应函数，按绑定的顺序执行
  * 支持IE8以上
  * 事件字符串：不带on的事件
  * bool：是否在捕获阶段触发事件，一般传false
* attachEvent("事件字符串带on",function(){})
  * 也可绑定多个响应函数，后绑定的先执行 

BOM
---
* window
  * 代表整个浏览器窗口
  * 是网页的全局对象
* Navigator
  * 当前浏览器的信息
  * 通过Navigator可识别不同的browser 
* Location
  * 当前浏览器的地址栏信息
* History
  * 浏览器的历史记录
  * 由于隐私限制，无法获取到具体的历史记录，因此只能操作浏览器进行翻页功能，且仅在当次访问时有效
* Screen
  * 用户的显示器参数信息

JSON：JavaScript Object Notation
---
* JSON是特殊格式的字符串
 * 可以被任何语言识别，且可转为任何语言中的对象
 * 开发中，用于数据交互
 * json与js对象格式一致，但属性名必须加引号
* JSON分类
  * 对象：'{"age":126}'
  * 数组："[1,3,3]"
* 将json字符串转为对象
  * JSON.parse()
  * var msg = '{"age":16}'; var newMsg = JSON.parse(msg);
* js对象转json字符串
  * JSON.stringify() 


常见问题
---
* typeof：
  * 可判断undefined,number,string,boolean,function
  * 无法判断null与object，array与object
* instanceof
  * 判断对象的具体类型
* ===
  * 可以判断undefined,null
* undefined与null的区别？
  * undefined表定义了但未赋值
  * null表定义了且赋值为null
* 何时为变量赋值为null？
  * 初始赋值，表明将要赋值为对象
  * 结束前， 使对象变成垃圾对象被回收
* 如何严格区别数据类型与变量类型？
  * 数据类型分为两种，基本数据类型，对象
  * 变量类型
    * 基本类型：保存的是基本类型的数据
    * 引用类型：保存的是地址值
* 什么是数据？
  * 存储在内存中代表特定信息的东西，本质上是01010
* 什么是内存?
  * 内存条通电后，产生的临时的可存储数据的空间
  * 内存的产生与死亡：
    * 内存条通电 -> 产生内存空间 -> 存储数据 -> 处理数据 -> 断电 -> 内存空间与数据消失
  * 一块内存的两个数据：
    * 内部存储的数据
    * 地址值
  * 内存分类：
    * stack,heap
* 什么是变量？
  * 可变化的量，由变量名和变量值组成 
  * 每个变量均对应一块内存 
    * 变量名用于查找对应内容
    * 值是内存中保存的数据
* 内存，数据，变量之间的关系
  * 内存是用于存储数据的空间
  * 变量是内存的标识

* var a = xxx，则a内存中保存的是什么？(分情况讨论)
  * 若xxx为基本数据时，保存的就是该数据
  * 为对象时，保存的则是该对象的地址值
  * 为变量时，保存的xxx的内容(可能是基本数据，也可能是地址)

* 关于引用变量赋值的问题
  * var obj1 = {name:"z"};
  * var obj2 = obj1;
  * obj1.name = "s";
  * console.log(obj2.name);  // "s"
  * 当n个引用变量指向同一个对象时，通过一个变量修改对象内部的数据，另一个变量也会改变
  * var a = {age:16};
  * var b = a;
  * a = {name:"s",age:13};
  * console.log(b.age,a.name,a.age);  // 16,"s",13
  * 当n个引用变量指向同一个对象，让其中一个引用变量指向另一个对象时，另一个引用变量仍指向前一个对象

* js调用函数时，传递变量参数时，是值传递还是引用传递？
  * 都是值(基本/地址值)传递
  * 可能是值，也可能是引用传递
* js如何管理内存？
  * 内存的生命周期
    * 分配小内存空间，取得使用权
    * 存放数据(可反复操作)
    * 释放内存空间 
  * 释放内存
    * 局部变量：函数执行完后，自动释放！
    * 对象：转为垃圾对象(即赋值为null)，由回收器回收
* 什么是对象？
  * 多个数据的封装体
  * 用来保存多个数据的容器
* 为什么使用对象？
  * 统一管理多个数据
* 对象的组成？
  * 属性：属性名(字符串) + 属性值(任意类型数据)
  * 方法：一种特别的属性(属性值是函数)
* 如何访问对象内部的数据？
  * .属性名
  * ["属性名"]，较为通用
* 何时使用["属性名"]的方式访问数据?
  * 属性名包含特殊字符，如 -，空格之类的
  * 变量名不确定

* 什么是函数？
  * 实现特定功能的n条语句的封装体
  * 只有函数可执行，其他类型数据不可执行
* 为什么使用函数？
  * 提高代码的复用性
  * 便于阅读交流
* 如何定义一个函数？
  * 函数表达式 var fun = function(){}
  * 函数声明 ，function fun(){} 
* 如何调用一个函数？
  * 直接调用，fun()
  * 通过对象调用，obj.fun()
  * new fun() 
  * fun.call/apply(obj);  //临时让fun成为obj的方法使用














   

 
