Basic
=====
JS的组成
-----
* ECMAScript
* DOM(文档对象模型)
* BOM(浏览器对象模型)

Js特点
---
* 解释型语言
* 类似C、Java的语法结构
* 动态语言
* 基于原型的面向对象

基础认知
---
* 字面量
  * 一些不可改变的值，如1，2，3
  * 字面量可直接使用，但一般不用

* 变量
  * 可以用于保存字面量，且变量的值可以任意改变

* 标识符
  * 可以包含：字母，数字，下划线，$
  * 不能以数字开头
  * 不能是ES标准中的关键字或保留字
  * 一般采用驼峰命名

* 注意事项
  * js底层标识符保存时，采用unicode编码，即utf-8含有的内容，均可作为标识符

数据类型 == 字面量的类型
---
* 基本数据类型
  * String
  * Number
    * 所有数值均为NumberLeixing ,包括浮点
    * js中，整数运算基本可以保证精确，但若进行浮点运算，会得到一个不精确的数字  
  * Boolean
  * NULL
    * NULL类型只有一个值，Null
    * Null表示一个空对象 
  * Undefined
    * Undefined类型只有一个值，Undefined
    * 当声明一个变量，但不进行赋值，此时该变量为Undefined 

  * typeof
    * 用于检查一个变量的类型
    * 用法：typeof 变量名 
    * special：typeof null -> object，typeof undefined -> undefined，typeof NaN -> Number

  * NaN
    * 非数，not a number 

* 引用数据类型
  * Object

强制类型转换
---
* 其他类型转String
  * Plan A：调用被转换数据类型的toString()方法，如，var a = 1; a = a.toString();   // a = "1";
    * 该方法不会影响原变量，但会将转换后的结果返回
    * Null,Undefined无toString()方法
  * Plan B：调用String()方法，如,String(a);
    * 对于Number，Boolean来说，调用String()，实际相当于调用toString()
    * 对于Null,Undefined，则会转为"Null"，"Undefined"

* 其它转Number
  * Plan A：调用Number()，即 a = Number(a);
    * 若字符串是纯数字，则会转为数字
    * 若有非数，则为NaN
    * 若是空串，或为空格，则为0
    * true -> 1，false -> 0，null -> 0，undefined -> NaN  
  * Plan B：parseInt()
    * 将串中有效的整数取出，转为Number，如 a = parseInt(a);
  * Plan C：parseFloat()
    * 操作与parseInt相同，不仅能获取整数，还能获取小数
  * 若对非String使用parseInt，parseFloat，会将其先转为String，后再进行判断，如
    * a = true; a = parseInt(a); console.log(typeof a); // Number console.log(a); // NaN

* 其它转Boolean
  * 数字 -> Bool，除0，NaN外，均为true
  * 字符串 -> Bool，除空串外，均为true
  * Null,Undefined -> Bool，为false
  * Object -> Bool,true 

对象
---
* 基本数据类型都是单一的值，值与值之间没有联系
* 对象作为复合的数据类型，对象可保存多个不同数据类型的属性
  * 内建对象
    * 由ES标准中定义的对象，在任何ES中均可使用，如Math，String...
  * 宿主对象
    * 由js的运行环境提供的对象，主要是浏览器提供，如DOM,BOM
  * 自定义对象
    * 由开发人员自行创建

* 对象的创建
  * 用new调用的函数，是构造函数constructor
  * 构造函数，专门用于创建对象

* 属性
  * 对象中保存的值，即属性
  * 属性的添加/修改：对象.属性名 = 属性值
  * 属性的读取：对象.属性名
    * 若读取的属性不存在，不会报错，而会返回undefined
  * 属性的删除：delete 对象.属性名


* 特殊属性名
  * 对象["属性名"] = 属性值，读取也使用该法
  * []中可直接传递一个变量，如，obj["123"] = 789; var n = "123"; console.log(obj[n]); // 789

* 属性值
  * js对象的属性值，可以是任意数据类型，也可以是一个对象 
  * 检查一个对象是否有指定属性： "属性名" in 对象

基本数据类型，引用数据类型的存储方式
---
* js中的变量保存在栈内存中
* 基本数据类型的值存在栈内存中
  * 值之间独立存在，修改一个变量不影响其他变量
* 对象保存在堆内存中
  * 每创建一个新对象，就开辟出一个新的内存空间，而变量保存的是对象的内存地址（引用地址）
  * 若两个变量保存的是同一个对象的地址，则修改时会互相影响
* 当比较两个基本数据类型的值时，直接比较值，若比较引用数据类型的值时，则比较对象的内存地址

对象字面量创建对象
* var obj = {属性名:属性值}; //键值对

函数
---
* 函数属于对象
  * 可用于封装一些功能，需要时执行
* 函数声明创建函数
  * function 函数名(形参){}
* 函数表达式创建函数
  * var 函数名 = function(形参){}
* 形参
  * 多个形参之间，逗号隔开
  * 声明形参，相当于在函数内部声明对应的变量，但不赋值！！
* 实参
  * 调用函数时，在()中指定实参
  * 实参会赋值给函数中对应的形参
  * 调用函数时，解析器不会检查实参数量！多余实参不会被赋值！
  * 若实参的数量少于形参，则无对应实参的形参的值为undefined

返回值
---
* return后的值会作为函数的执行结果返回
* 函数中，在return语句执行后的语句都不会执行
* 若return后面不跟任何值，则相当于返回一个undefined，即 return; 若函数中不写return，则也会返回undefined

枚举对象中的属性
---
* for(var 变量 in 对象){}
* for in，对象有几个属性，循环体就执行对应的次数，且每次执行时，会将对象中的一个属性的名字赋值给变量
* 语法：var obj = {name:"z",gender:"male"}; for(var i in obj){ console.log(i); //name gender console.log(obj[i]);//"z" "male" } 

作用域
---
* 作用域，指一个变量的作用范围
* 分为全局作用域，函数作用域
* 全局作用域
  * 直接写在script标签中的js代码，处于全局作用域
  * 全局作用域，在页面打开时创建，关闭时销毁
  * 含有一个全局对象window，由浏览器创建，代表浏览器的窗口
  * 全局作用域中，创建的变量会作为window对象的属性保存！创建的函数会作为window的方法保存！
* 函数作用域
  * 调用函数时创建，函数执行完毕销毁
  * 每次调用函数，都会创建一个新的作用域，且它们之间独立存在
  * 函数作用域中，可访问到全局的变量，而全局则无法访问到函数作用域内部的变量
  * 在函数作用域中操作变量时，会先在自身作用域寻找，若没有，则向上查找，直到全局，若全局也找不到，则报错ReferenceError

this的指向
---
* 浏览器在调用函数时，每次都会向函数内部传一个隐含参数：this
* this指向一个对象，即函数执行的上下文对象
* 根据函数的调用方式的不同，this也会指向不同的对象
  * 以函数形式调用时，this指向window，如：func(); // this -> window
  * 以方法形式调用时，this指向调用方法的那个对象，如 var per = func(); // this -> per 

变量和函数的声明提前
---
* 变量声明提前
  * 使用var声明的变量，会在所有代码执行前被声明，但不赋值！ 
* 函数声明提前
  * 使用function 函数名(){}，即函数声明形式创建的函数，会在所有代码执行前被创建

构造函数
---
* 其创建方式与普通函数没有区别，唯一特别，采用大驼峰命名
* 调用方法与普通函数不同，使用new调用
* 执行流程：
  * 创建一个新对象 
  * 将新建的对象，设置为函数中的this
  * 逐步执行函数中的代码
  * 将新建的对象作为返回值返回
  * function Person(name,age){this.name = name, this.age = age}   var man = new Person("Wow",16);
* 使用同一构造函数创建的对象，称为一类对象，也将一个构造函数成为一个类
* 通过一个构造函数创建的对象，成为该类的实例，如201行的man，称man是Person类的一个实例
* 检查一个对象是否是一个类的实例的方法：
  * 对象 instanceof 类，man instanceof Person;

原型
---
* 我们所创建的每一个函数，解析器都会向函数中添加属性prototype，该属性对应着一个对象，即原型对象
* 若函数作为普通函数调用prototype时，没有任何作用
* 以构造函数调用时，它所创建的对象都有一个隐含属性指向该构造函数的原型对象，即 _ _proto_ _
* 原型对象，相当于一个公共区域，所有同一个类的实例都能访问
  * 因此可将对象中共有的内容，统一设置到原型对象中
  * 优点：不污染全局，不用给每个对象添加，就能具有属性，方法
* 向原型添加属性：
  * 类名.prototype.属性名 = 值;
  * 当访问对象的一个属性或方法时，会在自身对象中寻找，找不到会去原型找
* 检查对象中是否含有某个属性：
  * "属性名" in 对象;
  * 该方法若对象中没有，而原型有，也会返回true
  * 对象.hasOwnProperty("属性名"); 
  * 该方法只有对象自身含有属性时，才返回true
* 注意：
  * 原型对象也有原型
  * 属性的查找，会一直到Object的原型，若在Object中没有找到，则返回undefined
* 附加
  * 若直接在页面打印一个对象，实际上是在输出该对象的toString()方法的返回值
  * 若想在输出对象时，不输出[object Object]，则可为对象添加toString()方法，如下：
  * var per = new Person("z",16);
  * Person.prototype.toString = function(){
  *   return "Person[name = +'this.name'+, age = +'this.age'+]";
  * }
  * var result = per.toString();
  * console.log(result);

垃圾回收(GC)
---
* 当一个对象没有任何变量或属性引用它时，此时就为垃圾
* 垃圾过多时，会占用大量内存空间，导致程序运行变慢
* js中有自动的垃圾回收机制

数组
---
* 数组也是对象，用于存储值，存储性能优于普通对象
* 数组的创建：
  * var arr = new Array();
  * var arr = [1,23,3];
* 向数组中添加元素
  * 数组[索引] = 值;
* 向数组最后一位添加元素
  * 数组[数组.length] = 值; 
* 读取数组中的元素
  * 数组[索引]，若索引不存在，则返回undefined
* 获取数组的长度
  * 数组.length
  * 对于内部数据连续的数组，length可以获取到元素的个数
  * 对于不连续的数组，length获取到的则是最大索引值+1
  * 修改length时，若length大于原长度，则多出的部分会空着，若小于，则多出的元素会被删除

数组字面量
---
* 创建数组：
  * var arr = [];
* 使用字面量创建数组时，可以在创建时就指定数组元素
* 使用构造函数创建数组，也可同时添加元素，将元素作为构造函数的参数传递，元素之间逗号隔开
  * var arr = new Array(10,20);
  * arr = new Array(10); //长度为10的数组
  * 数组中的元素可以是任何类型的数据

数组的操作方法
---
* push()
  * 向数组末尾添加元素，并将数组新的长度作为返回值返回
  * var arr = [1,2,3];
  * var result = arr.push(3,3,3);
  * console.log(result); // 6
* pop()
  * 删除最后一个元素，并将被删除的元素作为返回值返回
  * arr.pop();
* unshift()
  * 向开头添加元素，并返回新的数组长度
* shift()
  * 删除第一个元素，并将被删除的元素作为返回值返回








   

 
